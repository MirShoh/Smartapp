<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuroSurge: AI Hand-Controlled Medical Sim</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050a14; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        
        /* Loading Screen */
        #loader { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #02040a; display: flex; flex-direction: column; 
            justify-content: center; align-items: center; z-index: 10;
            color: #00f3ff; transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #1a2b45; 
            border-top: 5px solid #00f3ff; border-radius: 50%; 
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* HUD Elements */
        .hud-panel {
            position: absolute; background: rgba(5, 15, 30, 0.85); 
            border: 1px solid #00f3ff; color: #fff; padding: 15px; 
            border-radius: 8px; backdrop-filter: blur(5px);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            pointer-events: auto;
        }

        #info-panel { top: 20px; right: 20px; width: 300px; }
        #controls-panel { bottom: 20px; left: 20px; max-width: 350px; }
        
        h2 { margin: 0 0 10px 0; color: #00f3ff; font-size: 1.2rem; text-transform: uppercase; letter-spacing: 1px; }
        p { font-size: 0.9rem; line-height: 1.4; color: #ccc; margin-bottom: 5px; }
        
        .gesture-icon { display: inline-block; width: 20px; text-align: center; margin-right: 5px; color: #ffd700; }
        
        /* Dynamic Label for 3D Objects */
        #object-label {
            position: absolute; padding: 8px 12px; background: rgba(0, 0, 0, 0.8);
            border-left: 3px solid #00f3ff; color: #fff; font-size: 0.9rem;
            border-radius: 0 4px 4px 0; pointer-events: none; opacity: 0;
            transition: opacity 0.2s; transform: translate(-50%, -100%);
        }

        /* Webcam Feedback (Small) */
        .input_video { 
            position: absolute; bottom: 20px; right: 20px; 
            width: 160px; height: 120px; border-radius: 8px; 
            border: 2px solid #333; opacity: 0.7; z-index: 5; 
            transform: scaleX(-1); /* Mirror */
        }

        .mode-badge {
            display: inline-block; padding: 4px 8px; background: #00f3ff; 
            color: #000; font-weight: bold; border-radius: 4px; font-size: 0.7rem; margin-bottom: 10px;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <video class="input_video" autoplay playsinline muted></video>

    <div id="loader">
        <div class="spinner"></div>
        <h3>Initializing Neural Lab...</h3>
        <p>Please allow camera access for gesture control.</p>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="object-label">Label</div>

        <div id="info-panel" class="hud-panel">
            <div class="mode-badge" id="current-mode">ANATOMY MODE</div>
            <h2 id="target-name">Select an Organ</h2>
            <p id="target-desc">Hover over an object to analyze data.</p>
            <div id="stats" style="margin-top:10px; border-top:1px solid #333; padding-top:5px; font-size:0.8rem; color:#888;">
                System: <span id="target-sys">--</span>
            </div>
        </div>

        <div id="controls-panel" class="hud-panel">
            <h2>Gesture Controls</h2>
            <p><span class="gesture-icon">üñê</span> <strong>Open Palm:</strong> Hover / Select</p>
            <p><span class="gesture-icon">ü§è</span> <strong>Pinch (Index+Thumb):</strong> Grab & Move</p>
            <p><span class="gesture-icon">‚úä</span> <strong>Fist:</strong> Pathology View (Explode)</p>
            <p><span class="gesture-icon">üëã</span> <strong>Wave:</strong> Reset Scene</p>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            cameraZ: 5,
            grabThreshold: 0.08, // Sensitivity for pinching
            lerpFactor: 0.2 // Smoothness of hand tracking (0.1 = slow/smooth, 1 = instant)
        };

        // --- STATE MANAGEMENT ---
        let state = {
            handVisible: false,
            pinching: false,
            fist: false,
            hoveredObject: null,
            grabbedObject: null,
            handPosition: new THREE.Vector3(), // Mapped 3D position
            previousPinchDist: 0
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050a14, 0.05);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = CONFIG.cameraZ;
        camera.position.y = 1;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const blueLight = new THREE.PointLight(0x00f3ff, 1, 10);
        blueLight.position.set(-5, 2, 0);
        scene.add(blueLight);

        // Environment: Grid Floor
        const gridHelper = new THREE.GridHelper(20, 20, 0x1a2b45, 0x0a1525);
        gridHelper.position.y = -2;
        scene.add(gridHelper);

        // --- MEDICAL OBJECT GENERATION ---
        const objects = [];
        
        // Helper to create glowing materials
        function createMaterial(color, transparent = true) {
            return new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 0.2,
                roughness: 0.1,
                transmission: transparent ? 0.6 : 0, 
                opacity: transparent ? 0.8 : 1,
                transparent: transparent,
                side: THREE.DoubleSide
            });
        }

        // 1. Heart (Red Deformed Sphere)
        const heartGeo = new THREE.SphereGeometry(0.6, 32, 32);
        // Deform slightly to look like a heart (very basic abstract)
        const heartMat = createMaterial(0xff0040);
        const heart = new THREE.Mesh(heartGeo, heartMat);
        heart.position.set(0, 0.5, 0);
        heart.userData = { 
            name: "Human Heart", 
            desc: "Pumps blood through the circulatory system. 4 chambers.", 
            system: "Circulatory",
            originalColor: 0xff0040
        };
        scene.add(heart);
        objects.push(heart);

        // 2. Brain (Pink Torus Knot - Abstract)
        const brainGeo = new THREE.TorusKnotGeometry(0.5, 0.2, 100, 16);
        const brainMat = createMaterial(0xffaaee);
        const brain = new THREE.Mesh(brainGeo, brainMat);
        brain.position.set(-2, 0.5, 0);
        brain.userData = { 
            name: "Brain", 
            desc: "Central organ of the nervous system. Controls thought & motor function.", 
            system: "Nervous",
            originalColor: 0xffaaee
        };
        scene.add(brain);
        objects.push(brain);

        // 3. Kidney (Blue Capsule)
        const kidneyGeo = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
        const kidneyMat = createMaterial(0x4488ff);
        const kidney = new THREE.Mesh(kidneyGeo, kidneyMat);
        kidney.position.set(2, 0.5, 0);
        kidney.rotation.z = Math.PI / 4;
        kidney.userData = { 
            name: "Kidney", 
            desc: "Filters waste from blood to form urine.", 
            system: "Excretory",
            originalColor: 0x4488ff
        };
        scene.add(kidney);
        objects.push(kidney);

        // 4. Scalpel (Tool)
        const toolGeo = new THREE.BoxGeometry(0.1, 1.5, 0.1);
        const toolMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2 });
        const scalpel = new THREE.Mesh(toolGeo, toolMat);
        scalpel.position.set(0, -1, 1);
        scalpel.rotation.z = Math.PI / 2;
        scalpel.userData = { 
            name: "Surgical Scalpel", 
            desc: "Precision instrument for tissue incisions.", 
            system: "Instrument",
            originalColor: 0xcccccc
        };
        scene.add(scalpel);
        objects.push(scalpel);

        // --- HAND TRACKING & INTERACTION ---
        
        // 3D Cursor (Visualizes where your hand is)
        const cursorGeo = new THREE.SphereGeometry(0.05, 16, 16);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0x00f3ff });
        const cursor = new THREE.Mesh(cursorGeo, cursorMat);
        scene.add(cursor);

        const raycaster = new THREE.Raycaster();

        // UI Elements
        const labelEl = document.getElementById('object-label');
        const nameEl = document.getElementById('target-name');
        const descEl = document.getElementById('target-desc');
        const sysEl = document.getElementById('target-sys');
        const loader = document.getElementById('loader');

        // MediaPipe Setup
        const videoElement = document.getElementsByClassName('input_video')[0];
        
        function onResults(results) {
            // Hide loader on first frame
            if (loader.style.opacity !== '0' && results.multiHandLandmarks) {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handVisible = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Map Coordinates (Index finger tip: landmark 8)
                // Normalize coordinates (-1 to 1) based on camera view
                // Video is mirrored, so we invert X
                const x = (1 - landmarks[8].x) * 2 - 1; 
                const y = -(landmarks[8].y * 2 - 1);
                
                // Map to 3D world space (approximate)
                const vector = new THREE.Vector3(x * 4, y * 3, 0); // Scale to scene size
                
                // Smooth movement (Lerp)
                state.handPosition.lerp(vector, CONFIG.lerpFactor);
                cursor.position.copy(state.handPosition);

                // 2. Gesture Detection
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const indexPip = landmarks[6]; // Knuckle
                const pinkyTip = landmarks[20];
                const pinkyMcp = landmarks[17]; // Base of pinky

                // Distance between thumb and index (Pinch)
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                state.pinching = distance < CONFIG.grabThreshold;

                // Fist Detection (Fingers curled below knuckles)
                // Simple check: is pinky tip lower than pinky base? (y is inverted in MP sometimes, but higher value = lower on screen)
                state.fist = (pinkyTip.y > pinkyMcp.y) && (indexTip.y > indexPip.y);

                interact();
            } else {
                state.handVisible = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // --- INTERACTION LOGIC ---

        function interact() {
            // Update Raycaster from Camera to Cursor position
            // Since cursor is moving in 3D world z=0, we cast a ray from camera through cursor
            const direction = state.handPosition.clone().sub(camera.position).normalize();
            raycaster.set(camera.position, direction);

            const intersects = raycaster.intersectObjects(objects);

            // HOVER LOGIC
            if (intersects.length > 0 && !state.grabbedObject) {
                const obj = intersects[0].object;
                
                if (state.hoveredObject !== obj) {
                    // Reset previous
                    if (state.hoveredObject) resetObjectVisuals(state.hoveredObject);
                    
                    state.hoveredObject = obj;
                    
                    // Highlight
                    obj.material.emissive.setHex(0x333333);
                    
                    // Update UI
                    updateUI(obj.userData, true);
                }
            } else if (!state.grabbedObject) {
                if (state.hoveredObject) {
                    resetObjectVisuals(state.hoveredObject);
                    state.hoveredObject = null;
                    updateUI(null, false);
                }
            }

            // GRAB LOGIC
            if (state.pinching && state.hoveredObject && !state.grabbedObject) {
                state.grabbedObject = state.hoveredObject;
                document.body.style.cursor = "grabbing";
            }

            if (!state.pinching && state.grabbedObject) {
                state.grabbedObject = null;
                document.body.style.cursor = "default";
            }

            if (state.grabbedObject) {
                // Move object with hand
                state.grabbedObject.position.lerp(state.handPosition, 0.2);
                
                // Add subtle rotation while holding
                state.grabbedObject.rotation.x += 0.01;
                state.grabbedObject.rotation.y += 0.02;
            }

            // PATHOLOGY / FIST LOGIC
            if (state.fist && state.hoveredObject) {
                // Simulate "Explosion" or Pathology view
                state.hoveredObject.scale.setScalar(1.2); // Swell
                state.hoveredObject.material.wireframe = true; // Show structure
                document.getElementById('current-mode').innerText = "PATHOLOGY MODE";
                document.getElementById('current-mode').style.background = "#ff0055";
            } else if (state.hoveredObject) {
                state.hoveredObject.scale.setScalar(1);
                state.hoveredObject.material.wireframe = false;
                document.getElementById('current-mode').innerText = "ANATOMY MODE";
                document.getElementById('current-mode').style.background = "#00f3ff";
            }

            // UPDATE LABEL POSITION
            if (state.hoveredObject || state.grabbedObject) {
                const activeObj = state.grabbedObject || state.hoveredObject;
                const vector = activeObj.position.clone();
                vector.project(camera);
                
                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (-(vector.y * .5) + .5) * window.innerHeight;
                
                labelEl.style.left = `${x}px`;
                labelEl.style.top = `${y - 40}px`;
                labelEl.style.opacity = 1;
                labelEl.innerText = activeObj.userData.name;
            } else {
                labelEl.style.opacity = 0;
            }
        }

        function resetObjectVisuals(obj) {
            obj.material.emissive.setHex(0x000000);
            obj.material.wireframe = false;
            obj.scale.setScalar(1);
        }

        function updateUI(data, isVisible) {
            if (isVisible && data) {
                nameEl.innerText = data.name;
                descEl.innerText = data.desc;
                sysEl.innerText = data.system;
            } else {
                nameEl.innerText = "Select an Organ";
                descEl.innerText = "Hover over an object to analyze data.";
                sysEl.innerText = "--";
            }
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Idle animation for objects
            const time = Date.now() * 0.001;
            objects.forEach((obj, index) => {
                if (obj !== state.grabbedObject) {
                    obj.position.y += Math.sin(time + index) * 0.002;
                }
            });

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>