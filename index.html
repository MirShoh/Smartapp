<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Sky Toy Sort - Magic Hand Game</title>
    <!-- Tailwind CSS for UI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #87CEEB; 
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            touch-action: none; /* Prevent scroll on mobile */
            user-select: none;
            -webkit-user-select: none;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Fun UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px;
        }

        /* Camera Preview - Cute Frame */
        .cam-preview {
            position: absolute; top: 20px; right: 20px; width: 240px; height: 180px; 
            border-radius: 20px; overflow: hidden; border: 6px solid #FFD700;
            transform: scaleX(-1); /* Mirror effect */
            background: #fff;
            z-index: 20;
            box-shadow: 0 8px 0px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        /* Mobile adjustments for preview */
        @media (max-width: 640px) {
            .cam-preview {
                width: 120px;
                height: 90px;
                top: 10px;
                right: 10px;
                border-width: 3px;
            }
        }
        
        .score-board {
            background: rgba(255, 255, 255, 0.9);
            border: 4px solid #FF6B6B;
            border-radius: 30px;
            padding: 10px 30px;
            font-size: 2.5rem;
            color: #FF6B6B;
            font-weight: 900;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.1);
            box-shadow: 0 8px 0 rgba(0,0,0,0.1);
            animation: bounceIn 1s;
        }

        .level-badge {
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
            border: 2px solid white;
            padding: 5px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            margin-top: 10px;
            display: inline-block;
        }

        @media (max-width: 640px) {
            .score-board {
                font-size: 1.5rem;
                padding: 5px 15px;
                border-width: 3px;
            }
            .level-badge {
                font-size: 1rem;
                padding: 4px 12px;
            }
        }

        .gesture-bubble {
            background: white;
            padding: 15px 30px;
            border-radius: 50px;
            color: #4ECDC4;
            font-weight: bold;
            font-size: 1.5rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 3px solid #4ECDC4;
            transition: transform 0.2s;
        }

        @media (max-width: 640px) {
            .gesture-bubble {
                padding: 8px 16px;
                font-size: 1rem;
                border-width: 2px;
            }
        }

        /* Loading Screen - Kid Friendly */
        #loader {
            position: fixed; inset: 0; background: #87CEEB; z-index: 50;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; transition: opacity 0.5s;
            background-image: radial-gradient(circle, #87CEEB 10%, #4FA3D1 90%);
            padding: 20px;
            text-align: center;
        }
        
        .start-btn {
            background: #FFD700; color: #E67E22; border: none;
            padding: 20px 60px; font-size: 2rem; border-radius: 50px;
            font-weight: 900; cursor: pointer;
            box-shadow: 0 10px 0 #E67E22, 0 20px 20px rgba(0,0,0,0.2);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .start-btn:active {
            transform: translateY(10px);
            box-shadow: 0 0 0 #E67E22, 0 0 0 rgba(0,0,0,0);
        }

        /* Level Up Overlay */
        #level-overlay {
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #level-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        @keyframes popUp {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .level-text {
            animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); } 60% { transform: scale(1.1); } 100% { transform: scale(1); }
        }
        
        @keyframes popScore {
            0% { transform: scale(1); } 50% { transform: scale(1.5) rotate(-10deg); } 100% { transform: scale(1); }
        }
        
        .score-pop { animation: popScore 0.3s ease-out; }

        /* Instructions Panel */
        .instructions {
            background: rgba(255,255,255,0.95);
            border-radius: 20px;
            padding: 20px;
            max-width: 300px;
            border: 4px solid #4ECDC4;
            box-shadow: 0 8px 0 rgba(0,0,0,0.1);
        }
        .instruction-row { display: flex; align-items: center; margin-bottom: 10px; font-size: 1.1rem; color: #555; }
        .emoji-icon { font-size: 2rem; margin-right: 15px; width: 40px; text-align: center; }

        @media (max-width: 640px) {
            .instructions {
                padding: 10px;
                max-width: 100%;
                width: 100%;
                margin-top: 10px;
                display: flex;
                flex-wrap: wrap;
                justify-content: space-around;
            }
            .instruction-row {
                font-size: 0.8rem;
                margin-bottom: 0;
            }
            .emoji-icon {
                font-size: 1.2rem;
                margin-right: 5px;
            }
        }
    </style>
</head>
<body>

    <!-- Loading / Start Screen -->
    <div id="loader">
        <h1 class="text-4xl md:text-6xl font-black mb-4 text-white drop-shadow-lg tracking-wider" style="-webkit-text-stroke: 2px #333;">SKY TOY SORT</h1>
        <div class="text-lg md:text-2xl text-white mb-10 font-bold bg-white/20 px-6 py-2 rounded-full">Use your hands or touch screen!</div>
        <button id="start-btn" class="start-btn text-xl md:text-3xl px-8 py-4 md:px-16 md:py-6">PLAY!</button>
        <p id="status-text" class="mt-8 text-xl text-white font-bold hidden animate-pulse">Waking up the robots...</p>
    </div>

    <!-- Level Complete Overlay -->
    <div id="level-overlay" class="fixed inset-0 z-40 flex items-center justify-center bg-black/40 backdrop-blur-sm">
        <div class="text-center">
            <h2 id="level-title" class="text-5xl md:text-8xl font-black text-yellow-300 drop-shadow-[0_4px_0_#d97706] mb-2 level-text">AWESOME!</h2>
            <p id="level-sub" class="text-2xl md:text-4xl font-bold text-white drop-shadow-md">Next Level Coming...</p>
        </div>
    </div>

    <!-- Webcam Feed -->
    <video id="input-video" class="hidden" playsinline></video>
    <div class="cam-preview">
        <canvas id="output-canvas" width="240" height="180"></canvas>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="hidden">
        <div class="flex justify-between items-start w-full">
            <div class="flex flex-col items-start">
                <div id="score-display" class="score-board">
                    ‚≠ê 0
                </div>
                <div id="level-badge" class="level-badge">
                    Level 1 ‚Ä¢ Goal: 0/3
                </div>
            </div>
            <div id="gesture-indicator" class="gesture-bubble scale-0 transition-transform duration-200">
                ‚úã Ready!
            </div>
        </div>
        
        <div class="flex flex-col-reverse md:flex-row justify-between items-end w-full">
            <div class="instructions pointer-events-auto">
                <div class="instruction-row"><span class="emoji-icon">ü§è</span> <span><b>Pinch/Tap</b> to Grab</span></div>
                <div class="instruction-row"><span class="emoji-icon">üéØ</span> <span><b>Drag</b> to Ring</span></div>
                <div class="instruction-row"><span class="emoji-icon">üëã</span> <span><b>Release</b> to Score</span></div>
            </div>
        </div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // --- Sound Engine ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const Sound = {
            playTone: (freq, type, duration) => {
                if(audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            },
            playPop: () => {
                Sound.playTone(400 + Math.random()*200, 'sine', 0.1);
                setTimeout(() => Sound.playTone(600 + Math.random()*200, 'triangle', 0.1), 50);
            },
            playGrab: () => Sound.playTone(300, 'sine', 0.1),
            playSuccess: () => {
                const now = audioCtx.currentTime;
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    setTimeout(() => Sound.playTone(freq, 'sine', 0.4), i * 50);
                });
            },
            playLevelUp: () => {
                const now = audioCtx.currentTime;
                // Victory fanfare
                [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50].forEach((freq, i) => {
                    const d = i > 3 ? 0.4 : 0.2;
                    setTimeout(() => Sound.playTone(freq, 'square', d), i * 150);
                });
            }
        };

        // --- Configuration ---
        const CONFIG = {
            colors: [0xFF6B6B, 0x4ECDC4, 0xFFD93D, 0xFF9F43, 0xA3CB38],
            camZ: 8,
            // Dynamic smoothing config
            minSmoothing: 0.1, // Very smooth when slow
            maxSmoothing: 0.5, // Responsive when fast
            pinchThresholdStart: 0.50,
            pinchThresholdEnd: 0.85,
            
            // Level Definitions
            levels: [
                { target: 3, ringMode: 'static', title: "Warm Up!" },
                { target: 5, ringMode: 'horizontal', speed: 1.0, title: "Moving Target!" },
                { target: 8, ringMode: 'circle', speed: 1.5, title: "Pro Sorter!" },
                { target: 10, ringMode: 'figure8', speed: 2.0, title: "Master Class!" },
                { target: 999, ringMode: 'chaos', speed: 2.5, title: "Endless!" }
            ]
        };

        const state = {
            levelIndex: 0,
            levelCollected: 0,
            totalScore: 0,
            isTransitioning: false,

            gesture: 'NONE',
            handPosition: new THREE.Vector3(),
            prevHandPosition: new THREE.Vector3(),
            targetHandPosition: new THREE.Vector3(),
            handVelocity: new THREE.Vector3(),
            rawHandPos: { x: 0, y: 0 },
            isGrabbing: false,
            grabbedObject: null,
            hoveredObject: null,
            pinchValue: 1.0, 
            inputType: 'camera'
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 10, 25);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = CONFIG.camZ;
        camera.position.y = 2;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- Lights ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- Environment ---
        function createCloud() {
            const geo = new THREE.SphereGeometry(1, 7, 7);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            const cloud = new THREE.Group();
            
            for(let i=0; i<5; i++) {
                const puff = new THREE.Mesh(geo, mat);
                puff.position.set((Math.random()-0.5)*2, (Math.random()-0.5)*1, (Math.random()-0.5)*2);
                puff.scale.setScalar(0.5 + Math.random()*0.5);
                cloud.add(puff);
            }
            cloud.position.set((Math.random()-0.5)*30, (Math.random()-0.5)*10, -10 - Math.random()*10);
            scene.add(cloud);
            return cloud;
        }
        for(let i=0; i<10; i++) createCloud();

        // The Goal Ring
        const ringGeo = new THREE.TorusGeometry(1.5, 0.2, 16, 50);
        const ringMat = new THREE.MeshPhongMaterial({ color: 0xFFD700, shininess: 100, emissive: 0xaa6600, emissiveIntensity: 0.2 });
        const goalRing = new THREE.Mesh(ringGeo, ringMat);
        goalRing.position.set(0, -1, 0);
        goalRing.rotation.x = -Math.PI / 2;
        goalRing.castShadow = true;
        goalRing.receiveShadow = true;
        scene.add(goalRing);

        const glowGeo = new THREE.CircleGeometry(1.5, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const glowPlane = new THREE.Mesh(glowGeo, glowMat);
        glowPlane.rotation.x = -Math.PI / 2;
        glowPlane.position.y = -1;
        scene.add(glowPlane);

        // --- Toy System ---
        const toys = [];
        const geometries = [
            new THREE.BoxGeometry(0.8, 0.8, 0.8),
            new THREE.SphereGeometry(0.5, 32, 32),
            new THREE.ConeGeometry(0.5, 1, 32),
            new THREE.IcosahedronGeometry(0.5, 0),
            new THREE.TorusGeometry(0.4, 0.2, 16, 32)
        ];

        const toyMaterial = new THREE.MeshStandardMaterial({ roughness: 0.4, metalness: 0.1 });

        function spawnToy(pos) {
            const geo = geometries[Math.floor(Math.random() * geometries.length)];
            const color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            const mat = toyMaterial.clone();
            mat.color.setHex(color);

            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            if (pos) {
                mesh.position.copy(pos);
            } else {
                mesh.position.set(
                    (Math.random() - 0.5) * 8, // X
                    (Math.random() * 4) + 0,   // Y
                    (Math.random() - 0.5) * 3  // Z
                );
            }
            
            mesh.userData = {
                velocity: new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, 0),
                rotSpeed: new THREE.Vector3(Math.random()*0.02, Math.random()*0.02, Math.random()*0.02),
                id: Math.random().toString(),
                active: true
            };

            scene.add(mesh);
            toys.push(mesh);
            return mesh;
        }
        
        // Spawn initial wave
        for(let i=0; i<6; i++) spawnToy();

        // --- Cursor ---
        const cursorGroup = new THREE.Group();
        const cursorGeo = new THREE.SphereGeometry(0.2, 16, 16);
        const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        const cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
        const cursorRingGeo = new THREE.RingGeometry(0.25, 0.3, 32);
        const cursorRingMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const cursorRing = new THREE.Mesh(cursorRingGeo, cursorRingMat);
        
        cursorGroup.add(cursorMesh);
        cursorGroup.add(cursorRing);
        scene.add(cursorGroup);

        // --- Confetti ---
        const confetti = [];
        const confettiGeo = new THREE.PlaneGeometry(0.1, 0.1);
        
        function spawnConfetti(pos, color) {
            for(let i=0; i<20; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    color: color || CONFIG.colors[Math.floor(Math.random()*CONFIG.colors.length)], 
                    side: THREE.DoubleSide 
                });
                const p = new THREE.Mesh(confettiGeo, mat);
                p.position.copy(pos);
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5)*0.3, (Math.random()*0.3) + 0.1, (Math.random()-0.5)*0.3
                );
                scene.add(p);
                confetti.push(p);
            }
        }

        // --- Level Logic ---
        function updateLevelUI() {
            const currentLevel = CONFIG.levels[Math.min(state.levelIndex, CONFIG.levels.length-1)];
            const badge = document.getElementById('level-badge');
            badge.innerText = `Level ${state.levelIndex + 1} ‚Ä¢ Goal: ${state.levelCollected}/${currentLevel.target}`;
        }

        function triggerLevelUp() {
            if (state.isTransitioning) return;
            state.isTransitioning = true;
            Sound.playLevelUp();

            const overlay = document.getElementById('level-overlay');
            const sub = document.getElementById('level-sub');
            
            // Release grabbed object if any
            state.grabbedObject = null;
            state.gesture = 'OPEN';

            // Show UI
            overlay.classList.add('active');
            
            setTimeout(() => {
                // Clear existing toys
                toys.forEach(t => scene.remove(t));
                toys.length = 0;
                
                // Increment Level
                state.levelIndex++;
                state.levelCollected = 0;
                
                // Update UI Text for new level
                const nextLvl = CONFIG.levels[Math.min(state.levelIndex, CONFIG.levels.length-1)];
                sub.innerText = nextLvl.title;
                
                updateLevelUI();
                
                // Hide Overlay
                setTimeout(() => {
                    overlay.classList.remove('active');
                    state.isTransitioning = false;
                    
                    // Spawn new wave
                    for(let i=0; i<6; i++) spawnToy();
                }, 1500);

            }, 2000);
        }

        function processScore(object) {
            const scoreEl = document.getElementById('score-display');
            const currentLevel = CONFIG.levels[Math.min(state.levelIndex, CONFIG.levels.length-1)];

            Sound.playSuccess();
            spawnConfetti(object.position, 0xFFD700);
            
            state.totalScore += 10;
            state.levelCollected++;
            
            scoreEl.innerText = "‚≠ê " + state.totalScore;
            scoreEl.classList.remove('score-pop');
            void scoreEl.offsetWidth; 
            scoreEl.classList.add('score-pop');
            
            updateLevelUI();

            scene.remove(object);
            toys.splice(toys.indexOf(object), 1);
            
            // Check Level Completion
            if (state.levelCollected >= currentLevel.target) {
                triggerLevelUp();
            } else {
                setTimeout(() => spawnToy(), 500);
            }
        }

        // --- Logic Loop ---
        function updateGame() {
            if (state.isTransitioning) return;

            const bubble = document.getElementById('gesture-indicator');
            const currentLevel = CONFIG.levels[Math.min(state.levelIndex, CONFIG.levels.length-1)];

            // 1. Raycast
            if (!state.grabbedObject) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(state.ndc || {x:0, y:0}, camera);
                const intersects = raycaster.intersectObjects(toys);
                
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if (state.hoveredObject !== obj) {
                        if (state.hoveredObject) state.hoveredObject.scale.setScalar(1);
                        state.hoveredObject = obj;
                        Sound.playTone(800, 'sine', 0.05);
                    }
                    obj.scale.setScalar(1.2 + Math.sin(Date.now()*0.01)*0.1);
                    obj.rotation.x += 0.05;
                    cursorRing.scale.setScalar(1.5);
                    cursorRing.material.color.setHex(0x00FF00);
                } else {
                    if (state.hoveredObject) state.hoveredObject.scale.setScalar(1);
                    state.hoveredObject = null;
                    cursorRing.scale.setScalar(1);
                    cursorRing.material.color.setHex(0xFFFFFF);
                }

                // Check for score on RELEASE (Drop)
                for(let i = toys.length - 1; i >= 0; i--) {
                    const toy = toys[i];
                    if (toy.userData.active) {
                        const dist = toy.position.distanceTo(goalRing.position);
                        if (dist < 2.5) { // Generous drop zone
                            processScore(toy);
                        }
                    }
                }

            }

            // 2. State Machine
            if (state.gesture === 'PINCH') {
                bubble.innerText = "‚úä Grabbing!";
                bubble.classList.remove('scale-0');
                cursorMesh.material.color.setHex(0x00FF00);

                if (!state.grabbedObject && state.hoveredObject) {
                    state.grabbedObject = state.hoveredObject;
                    state.grabOffset = state.grabbedObject.position.clone().sub(state.handPosition);
                    Sound.playGrab();
                }

                if (state.grabbedObject) {
                    const target = state.handPosition.clone().add(state.grabOffset);
                    state.grabbedObject.position.copy(target);
                    state.grabbedObject.rotation.z = -state.handVelocity.x * 2.0; 
                    state.grabbedObject.rotation.x = state.handVelocity.z * 2.0;
                    state.grabbedObject.scale.setScalar(1.2);

                    // Check if over ring for feedback
                    const dist = state.grabbedObject.position.distanceTo(goalRing.position);
                    if (dist < 2.5) {
                        goalRing.material.emissive.setHex(0x00FF00); // Glow Green to signal drop
                        bubble.innerText = "üëã Release!";
                        
                        // AUTO-DUNK: If very close to center, score immediately
                        if (dist < 1.2) {
                            processScore(state.grabbedObject);
                            state.grabbedObject = null;
                            // Temporarily force open gesture to prevent re-grab flicker
                            // but allow MediaPipe to correct it on next frame
                        }

                    } else {
                        goalRing.material.emissive.setHex(0xaa6600);
                    }
                }
            } 
            else if (state.gesture === 'FIST') {
                bubble.innerText = "üí• POP!";
                bubble.classList.remove('scale-0');
                
                if (state.hoveredObject && !state.grabbedObject) {
                    spawnConfetti(state.hoveredObject.position, state.hoveredObject.material.color);
                    Sound.playPop();
                    scene.remove(state.hoveredObject);
                    toys.splice(toys.indexOf(state.hoveredObject), 1);
                    state.hoveredObject = null;
                    setTimeout(() => spawnToy(), 1000);
                }
            }
            else {
                bubble.classList.add('scale-0');
                cursorMesh.material.color.setHex(0xFFFFFF);
                
                // Reset ring glow if not holding
                if (goalRing.material.emissive.getHex() === 0x00FF00) {
                    goalRing.material.emissive.setHex(0xaa6600);
                }
                
                // Release Object
                if (state.grabbedObject) {
                    state.grabbedObject = null;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            state.prevHandPosition.copy(state.handPosition);
            
            // Adaptive Smoothing
            const speed = state.targetHandPosition.distanceTo(state.handPosition);
            const alpha = THREE.MathUtils.clamp(speed * 2, CONFIG.minSmoothing, CONFIG.maxSmoothing);
            
            state.handPosition.lerp(state.targetHandPosition, alpha);
            state.handVelocity.subVectors(state.handPosition, state.prevHandPosition);
            cursorGroup.position.copy(state.handPosition);

            const time = Date.now() * 0.001;

            // --- Level Based Ring Animation ---
            const lvl = CONFIG.levels[Math.min(state.levelIndex, CONFIG.levels.length-1)];
            const spd = lvl.speed || 0;

            if (lvl.ringMode === 'static') {
                goalRing.position.set(0, -1, 0);
            } 
            else if (lvl.ringMode === 'horizontal') {
                goalRing.position.x = Math.sin(time * spd) * 3;
                goalRing.position.y = -1;
            }
            else if (lvl.ringMode === 'circle') {
                goalRing.position.x = Math.cos(time * spd) * 3;
                goalRing.position.y = Math.sin(time * spd) * 1.5; 
            }
            else if (lvl.ringMode === 'figure8') {
                goalRing.position.x = Math.cos(time * spd) * 4;
                goalRing.position.y = Math.sin(time * spd * 2) * 2;
            }

            // Sync Glow
            glowPlane.position.copy(goalRing.position);
            goalRing.rotation.z = time * 0.5;
            glowPlane.scale.setScalar(1 + Math.sin(time*2)*0.1);

            toys.forEach(toy => {
                if (toy !== state.grabbedObject) {
                    toy.position.y += Math.sin(time + parseFloat(toy.userData.id))*0.005;
                    toy.rotation.x += toy.userData.rotSpeed.x;
                    toy.rotation.y += toy.userData.rotSpeed.y;
                }
            });

            for(let i=confetti.length-1; i>=0; i--) {
                const c = confetti[i];
                c.position.add(c.userData.vel);
                c.userData.vel.y -= 0.01;
                c.rotation.x += 0.1;
                c.scale.multiplyScalar(0.95);
                if(c.scale.x < 0.01) {
                    scene.remove(c);
                    confetti.splice(i, 1);
                }
            }

            updateGame();
            renderer.render(scene, camera);
        }

        // --- MediaPipe Handling ---
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('output-canvas');
        const canvasCtx = canvasElement.getContext('2d');

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.inputType = 'camera';
                const landmarks = results.multiHandLandmarks[0];
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
                
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];
                const wrist = landmarks[0];
                const indexMCP = landmarks[5];

                const handSize = Math.hypot(indexMCP.x - wrist.x, indexMCP.y - wrist.y);
                const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                const normalizedPinch = pinchDist / handSize; 
                state.pinchValue = normalizedPinch;

                // IMPROVED CURSOR TRACKING: Use midpoint of fingers for pinch center
                // This prevents the object from "jumping" when you close your fingers
                const midX = (indexTip.x + thumbTip.x) / 2;
                const midY = (indexTip.y + thumbTip.y) / 2;
                
                const ndcX = (1 - midX) * 2 - 1;
                const ndcY = -(midY * 2 - 1);
                state.ndc = {x: ndcX, y: ndcY};
                
                const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                state.targetHandPosition.copy(pos);

                if (state.gesture === 'PINCH') {
                    if (normalizedPinch > CONFIG.pinchThresholdEnd) state.gesture = 'OPEN';
                } else {
                    if (normalizedPinch < CONFIG.pinchThresholdStart) state.gesture = 'PINCH';
                }

                // Visual Pinch Guide (Hidden when pinching)
                if (state.gesture !== 'PINCH') {
                    let guideColor = '#FF4444';
                    let guideWidth = 2;
                    if (normalizedPinch < CONFIG.pinchThresholdEnd) {
                        guideColor = '#FFFF00';
                        guideWidth = 4;
                    }
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
                    canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
                    canvasCtx.strokeStyle = guideColor;
                    canvasCtx.lineWidth = guideWidth;
                    canvasCtx.stroke();
                    
                    canvasCtx.beginPath();
                    canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, 4, 0, 2 * Math.PI);
                    canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, 4, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = guideColor;
                    canvasCtx.fill();
                }
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        // --- Init ---
        const startBtn = document.getElementById('start-btn');
        const loader = document.getElementById('loader');
        const uiLayer = document.getElementById('ui-layer');

        startBtn.addEventListener('click', async () => {
            if(audioCtx.state === 'suspended') await audioCtx.resume();
            document.getElementById('status-text').classList.remove('hidden');
            startBtn.style.display = 'none';

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480, facingMode: 'user'
            });
            
            try { await cameraUtils.start(); } catch(e) { console.warn("Camera fallback"); }

            loader.style.opacity = 0;
            setTimeout(() => {
                loader.style.display = 'none';
                uiLayer.classList.remove('hidden');
                updateLevelUI();
            }, 500);

            handleResize();
            animate();
        });

        // Fallback Logic
        function updatePointerInput(x, y) {
            state.inputType = 'touch';
            const ndcX = (x * 2) - 1;
            const ndcY = -(y * 2) + 1;
            state.ndc = {x: ndcX, y: ndcY};
            const vector = new THREE.Vector3(ndcX, ndcY, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            state.targetHandPosition.copy(pos);
        }

        window.addEventListener('mousemove', (e) => {
            if (state.inputType === 'touch') updatePointerInput(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
        });
        window.addEventListener('mousedown', () => { if(state.inputType === 'touch') state.gesture = 'PINCH'; });
        window.addEventListener('mouseup', () => { if(state.inputType === 'touch') state.gesture = 'OPEN'; });

        window.addEventListener('touchstart', (e) => {
            if (e.target.id === 'start-btn' || e.target.closest('button')) return;
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                updatePointerInput(touch.clientX / window.innerWidth, touch.clientY / window.innerHeight);
                state.gesture = 'PINCH';
            }
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            if (e.target.id === 'start-btn') return;
            e.preventDefault();
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                updatePointerInput(touch.clientX / window.innerWidth, touch.clientY / window.innerHeight);
            }
        }, {passive: false});

        window.addEventListener('touchend', (e) => state.gesture = 'OPEN');

        function handleResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const aspect = width / height;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            if (aspect < 1) {
                camera.position.z = CONFIG.camZ + 8;
                camera.position.y = 4;
            } else {
                camera.position.z = CONFIG.camZ;
                camera.position.y = 2;
            }
            camera.lookAt(0, 0, 0);
        }
        window.addEventListener('resize', handleResize);

    </script>
</body>
</html>