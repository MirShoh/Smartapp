<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon AR Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: brightness(0.7) contrast(1.2); /* Videoni biroz qoraytiramiz, neon effektlar yaxshi ko'rinishi uchun */
            z-index: 0;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* HUD (Head-Up Display) Uslubi */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .hud-panel {
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 4px solid #00ffcc;
            padding: 15px 25px;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
            color: #fff;
            transform: skewX(-10deg); /* Futuristik qiyshiq shakl */
        }
        
        .hud-title {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #00ffcc;
            margin-bottom: 5px;
        }
        
        .score-value {
            font-size: 42px;
            font-weight: 800;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            font-family: 'Courier New', monospace;
        }

        #instruction {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff0055;
            color: #fff;
            padding: 10px 30px;
            font-size: 18px;
            border-radius: 30px;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 2;
            pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.4);
            transition: all 0.3s;
        }

        /* Yuklash ekrani */
        #loading {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            color: #00ffcc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 10;
            flex-direction: column;
        }
        .loader {
            width: 50px; height: 50px;
            border: 5px solid #333;
            border-top: 5px solid #00ffcc;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <!-- CameraUtils shart emas, chunki qo'lda yozamiz -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">Tizim ishga tushmoqda...</div>
    </div>

    <div id="container">
        <video id="input_video" playsinline></video>
        
        <div id="ui-layer">
            <div class="hud-panel">
                <div class="hud-title">SCORE</div>
                <div id="score" class="score-value">0000</div>
            </div>
            <div class="hud-panel" style="border-left-color: #ff0055;">
                <div class="hud-title">COMBO</div>
                <div id="combo" class="score-value" style="font-size: 24px; color: #ff0055;">x1</div>
            </div>
        </div>

        <div id="instruction">Kameraga ruxsat bering</div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- KONFIGURATSIYA ---
        const BALL_RADIUS = 0.28;
        const GRID_ROWS = 4;
        const GRID_COLS = 7;
        const COLORS = [0xff0055, 0x00ffcc, 0xbd00ff, 0xffcc00]; 
        const ANCHOR_POINT = new THREE.Vector3(0, -2.5, 0);

        let score = 0;
        let combo = 1;
        let gameState = 'IDLE'; 
        let currentBall = null;
        let balls = []; 
        let particles = [];
        let shootingVelocity = new THREE.Vector3();
        
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const mainLight = new THREE.PointLight(0xffffff, 1, 100);
        mainLight.position.set(5, 5, 5);
        scene.add(mainLight);
        
        const rimLight = new THREE.PointLight(0x00ccff, 0.8, 50);
        rimLight.position.set(-5, 5, -5);
        scene.add(rimLight);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 6);

        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        // --- 2. MATERIALLAR VA OBYEKTLAR ---
        const baseGeometry = new THREE.SphereGeometry(BALL_RADIUS, 32, 32);
        
        function createBall(color, x, y, z = 0) {
            const material = new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.6,
                thickness: 1.0,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
            });

            const mesh = new THREE.Mesh(baseGeometry, material);
            mesh.position.set(x, y, z);
            
            const coreGeo = new THREE.SphereGeometry(BALL_RADIUS * 0.6, 16, 16);
            const coreMat = new THREE.MeshBasicMaterial({ color: color });
            const coreMesh = new THREE.Mesh(coreGeo, coreMat);
            mesh.add(coreMesh);

            mesh.userData = { 
                radius: BALL_RADIUS, 
                color: color, 
                active: true,
                velocity: new THREE.Vector3(0,0,0)
            };
            scene.add(mesh);
            return mesh;
        }

        const particleGeo = new THREE.BufferGeometry();
        
        class Explosion {
            constructor(position, color) {
                this.particles = [];
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: color });
                
                for(let i=0; i<15; i++) {
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(position);
                    mesh.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    mesh.userData.life = 1.0;
                    scene.add(mesh);
                    this.particles.push(mesh);
                }
            }
            
            update() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.position.add(p.userData.velocity);
                    p.userData.life -= 0.05;
                    p.scale.setScalar(p.userData.life);
                    
                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        this.particles.splice(i, 1);
                    }
                }
                return this.particles.length > 0;
            }
        }
        let explosions = [];

        function initGrid() {
            balls.forEach(b => scene.remove(b));
            balls = [];

            const startX = -((GRID_COLS - 1) * BALL_RADIUS * 2) / 2;
            const startY = 3.5;
            
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const offsetX = (r % 2) * BALL_RADIUS;
                    const x = startX + c * BALL_RADIUS * 2 + offsetX;
                    const y = startY - r * BALL_RADIUS * 1.8;
                    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    balls.push(createBall(color, x, y));
                }
            }
        }
        initGrid();

        function spawnPlayerBall() {
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            currentBall = createBall(color, ANCHOR_POINT.x, ANCHOR_POINT.y, 2); 
            
            const targetZ = 0;
            const animateEntry = () => {
                if(currentBall && currentBall.position.z > targetZ) {
                    currentBall.position.z -= 0.2;
                    requestAnimationFrame(animateEntry);
                } else if(currentBall) {
                    currentBall.position.z = 0;
                }
            };
            animateEntry();
            
            gameState = 'IDLE';
        }
        spawnPlayerBall();

        const laserMat = new THREE.LineDashedMaterial({ 
            color: 0x00ffcc, 
            dashSize: 0.2, 
            gapSize: 0.1, 
            linewidth: 2 
        });
        const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
        const trajectoryLine = new THREE.Line(laserGeo, laserMat);
        trajectoryLine.computeLineDistances();
        scene.add(trajectoryLine);

        const cursorGroup = new THREE.Group();
        const ring1 = new THREE.Mesh(new THREE.RingGeometry(0.12, 0.15, 32), new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.8 }));
        const ring2 = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.07, 32), new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.8 }));
        cursorGroup.add(ring1);
        cursorGroup.add(ring2);
        scene.add(cursorGroup);

        // --- 3. MEDIAPIPE & LOGIC ---
        const videoElement = document.getElementById('input_video');
        const instructionEl = document.getElementById('instruction');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const loadingEl = document.getElementById('loading');

        let handPos = new THREE.Vector3(0, -10, 0);
        let isPinching = false;
        let isCameraRunning = false;

        function onResults(results) {
            if (!isCameraRunning) {
                loadingEl.style.display = 'none';
                isCameraRunning = true;
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];

                const ndcX = (0.5 - indexTip.x) * 2;
                const ndcY = (0.5 - indexTip.y) * 2;
                
                const targetX = ndcX * 7;
                const targetY = ndcY * 5;
                handPos.lerp(new THREE.Vector3(targetX, targetY, 0), 0.2); 
                
                cursorGroup.position.copy(handPos);
                cursorGroup.rotation.z += 0.05;

                const dx = indexTip.x - thumbTip.x;
                const dy = indexTip.y - thumbTip.y;
                const distance = Math.sqrt(dx*dx + dy*dy);

                isPinching = distance < 0.06;
                
                if (isPinching) {
                    ring1.material.color.setHex(0xff0055);
                    cursorGroup.scale.setScalar(0.8);
                } else {
                    ring1.material.color.setHex(0x00ffcc);
                    cursorGroup.scale.setScalar(1.0);
                }
            } else {
                isPinching = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        // --- YANGI KAMERA FUNKSIYASI (Xatolikni tuzatish uchun) ---
        async function startCamera() {
            try {
                // Oddiyroq constraints (ideal width/height), majburiy emas
                const constraints = {
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: "user"
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                
                // Video tayyor bo'lishini kutish
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play();
                        resolve();
                    };
                });

                // Frame loop: Qo'llarni aniqlash uchun videoni yuborib turamiz
                async function processVideo() {
                    if (videoElement.paused || videoElement.ended) return;
                    await hands.send({image: videoElement});
                    requestAnimationFrame(processVideo);
                }
                processVideo();

            } catch (error) {
                console.error("Kamera xatosi:", error);
                loadingEl.innerHTML = `
                    <div style="color: #ff0055; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;">
                        <div style="font-size: 50px;">üì∑‚ùå</div>
                        <h2 style="margin: 10px 0;">Kamera topilmadi</h2>
                        <p style="font-size: 16px; opacity: 0.8;">Iltimos, kamera ulanganini tekshiring<br>yoki ruxsat berilganligiga ishonch hosil qiling.</p>
                        <p style="font-size: 12px; color: #888;">Xatolik kodi: ${error.name}</p>
                    </div>
                `;
            }
        }

        startCamera();

        function updateGame() {
            explosions = explosions.filter(exp => exp.update());

            if (!currentBall) return;

            if (gameState === 'IDLE') {
                instructionEl.innerText = "Sharni chimchilab ushlang";
                instructionEl.style.borderColor = "#00ffcc";
                trajectoryLine.visible = false;

                const distToBall = handPos.distanceTo(currentBall.position);
                if (isPinching && distToBall < 1.0) {
                    gameState = 'DRAGGING';
                }
            }
            else if (gameState === 'DRAGGING') {
                instructionEl.innerText = "Nishonga oling va qo'yib yuboring!";
                instructionEl.style.borderColor = "#ff0055";

                const pullVector = new THREE.Vector3().subVectors(handPos, ANCHOR_POINT);
                const maxPull = 3.0;
                if (pullVector.length() > maxPull) pullVector.setLength(maxPull);
                
                currentBall.position.copy(ANCHOR_POINT).add(pullVector);

                trajectoryLine.visible = true;
                const shootDir = new THREE.Vector3().subVectors(ANCHOR_POINT, currentBall.position).normalize();
                const endPoint = new THREE.Vector3().copy(currentBall.position).add(shootDir.multiplyScalar(10)); 
                
                const points = [currentBall.position, endPoint];
                trajectoryLine.geometry.setFromPoints(points);
                trajectoryLine.computeLineDistances();

                if (!isPinching) {
                    gameState = 'SHOT';
                    trajectoryLine.visible = false;
                    shootingVelocity.subVectors(ANCHOR_POINT, currentBall.position).multiplyScalar(0.35); 
                }
            }
            else if (gameState === 'SHOT') {
                currentBall.position.add(shootingVelocity);

                if (currentBall.position.x > 7 || currentBall.position.x < -7) shootingVelocity.x *= -1;
                
                if (currentBall.position.y > 5.0) {
                     freezeBall();
                }

                for (let i = 0; i < balls.length; i++) {
                    const target = balls[i];
                    if (!target.userData.active) continue;

                    const dist = currentBall.position.distanceTo(target.position);
                    if (dist < BALL_RADIUS * 1.8) { 
                        handleCollision(target);
                        break;
                    }
                }
            }
        }

        function freezeBall() {
             gameState = 'FROZEN';
             balls.push(currentBall);
             combo = 1;
             updateUI();
             setTimeout(() => { if(gameState==='FROZEN') spawnPlayerBall(); }, 300);
        }

        function handleCollision(targetBall) {
            gameState = 'FROZEN';
            
            if (targetBall.userData.color === currentBall.userData.color) {
                explosions.push(new Explosion(targetBall.position, targetBall.userData.color));
                explosions.push(new Explosion(currentBall.position, currentBall.userData.color));

                score += 10 * combo;
                combo++;
                updateUI();

                scene.remove(targetBall);
                scene.remove(currentBall);
                
                const index = balls.indexOf(targetBall);
                if (index > -1) balls.splice(index, 1);

                instructionEl.innerText = `POP! +${10 * (combo-1)}`;
                instructionEl.style.color = "#ffff00";
            } else {
                balls.push(currentBall);
                combo = 1;
                instructionEl.innerText = "Yomon emas...";
                instructionEl.style.color = "#fff";
                updateUI();
            }

            if (balls.length === 0) {
                initGrid();
                score += 1000;
                instructionEl.innerText = "LEVEL CLEARED!";
            }

            setTimeout(() => {
                 spawnPlayerBall();
            }, 600);
        }

        function updateUI() {
            scoreEl.innerText = score.toString().padStart(4, '0');
            comboEl.innerText = "x" + combo;
            
            if(combo > 1) {
                comboEl.style.color = "#ffff00";
                comboEl.style.transform = "scale(1.5)";
                setTimeout(() => comboEl.style.transform = "scale(1)", 200);
            } else {
                comboEl.style.color = "#ff0055";
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateGame();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>